---
title: Artificial Languages, Part 1
author: Dave Dubin
date: March 27, 2017
header-includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage{amssymb}
  - \usepackage{mathtools}
---

# Grammars for artificial languages

- We've seen grammars in earlier presentations.
- Propositional logic:
    - Let $P$ be a set of proposition letters and let $p \in P$.
    - $\varphi \Coloneqq p|\neg\varphi|(\varphi \wedge \varphi)|(\varphi \vee \varphi)|(\varphi \rightarrow \varphi)|(\varphi \leftrightarrow \varphi)$
- Predicate logic:
    - $\textbf{v} \Coloneqq x|y|z|\ldots$
    - $\textbf{c} \Coloneqq a|b|c|\ldots$
    - $\textbf{t} \Coloneqq \textbf{v}|\textbf{c}$
    - $\textbf{P} \Coloneqq P|Q|R|\ldots$
    - $\textbf{Atom} \Coloneqq \textbf{Pt}_{1}\ldots\textbf{t}_{n}$ where $n$ is the arity of \textbf{P}
    - $\varphi \Coloneqq \textbf{Atom}|\neg\varphi|(\varphi \wedge \varphi)|(\varphi \vee \varphi)|(\varphi \rightarrow \varphi)|(\varphi \leftrightarrow \varphi)|{\forall}\textbf{v} \varphi|{\exists}\textbf{v} \varphi$

# Bottom-up parse

-   ${\forall}wx ((Fxw \wedge Aw) \rightarrow {\exists}yz ((Pxy \wedge Ay) \wedge (Fxz \wedge Dz)))$
- ${\forall}\textbf{vv} ((F\textbf{vv} \wedge A\textbf{v}) \rightarrow {\exists}\textbf{vv} ((P\textbf{vv} \wedge A\textbf{v}) \wedge (F\textbf{vv} \wedge D\textbf{v})))$
- ${\forall}\textbf{vv} ((\textbf{Pvv} \wedge \textbf{Pv}) \rightarrow {\exists}\textbf{vv} ((\textbf{Pvv} \wedge \textbf{Pv}) \wedge (\textbf{Pvv} \wedge \textbf{Pv})))$
- ${\forall}\textbf{vv} ((\textbf{Ptt} \wedge \textbf{Pt}) \rightarrow {\exists}\textbf{vv} ((\textbf{Ptt} \wedge \textbf{Pt}) \wedge (\textbf{Ptt} \wedge \textbf{Pt})))$
- ${\forall}\textbf{vv}((\textbf{Atom} \wedge \textbf{Atom})\rightarrow{\exists}\textbf{vv}((\textbf{Atom} \wedge \textbf{Atom}) \wedge (\textbf{Atom} \wedge \textbf{Atom})))$
- ${\forall}\textbf{vv} ((\varphi \wedge \varphi) \rightarrow {\exists}\textbf{vv} ((\varphi \wedge \varphi) \wedge (\varphi \wedge \varphi)))$
- ${\forall}\textbf{vv} ((\varphi \wedge \varphi) \rightarrow {\exists}\textbf{vv} ((\varphi \wedge \varphi) \wedge \varphi))$
- ${\forall}\textbf{vv} ((\varphi \wedge \varphi) \rightarrow {\exists}\textbf{vv} (\varphi \wedge \varphi))$
- ${\forall}\textbf{vv} (\varphi \rightarrow {\exists}\textbf{vv} (\varphi \wedge \varphi))$
- ${\forall}\textbf{vv} (\varphi \rightarrow {\exists}\textbf{vv}\varphi)$
- ${\forall}\textbf{vv} (\varphi \rightarrow \varphi)$
- ${\forall}\textbf{vv}\varphi$
- $\varphi$


# Rosen on vocabularies

> A *vocabulary* (or *alphabet*) $V$ is a finite nonempty set of
> elements, called *symbols*.  A *word* (or *sentence*) over $V$ is a
> string of finite length of elements of $V$. The *empty string* or
> *null string*, denoted by $\lambda$, is the string containing no
> symbols.  The set of all words over $V$ is denoted by $V^{*}$. A
> language over $V$ is a subset of $V^{*}$.

# Rosen on grammars

> A *phrase-structure grammar* $G = \langle V,T,S,P \rangle$ consists
> of a vocabulary $V$, a subset $T$ of $V$ consisting of terminal
> elements, a start symbol $S$ from $V$, and a set of productions
> $P$. The set $V - T$ is denoted by $N$. Elements of $N$ are
> called *nonterminal symbols.* Every production in $P$ must contain
> at least one nonterminal on its left side.

# Rosen on languages and derivability

> Let $G = \langle V,T,S,P \rangle$ be a phrase-structure grammar. Let
> $w_{0} = lz_{0}r$ (that is, the concatenation of $l$, $z_{0}$, and
> $r$) and $w_{1} = lz_{1}r$ be strings over $V$.  If $z_{0}
> \rightarrow z_{1}$ is a production of $G$, we say that $w_{1}$ is
> *directly derivable* from $w_{0}$ and we write $w_{0} \Rightarrow
> w_{1}$. If $w_{0}, w_{1},\ldots\, w_{n}, n \geq 0$, are strings over
> $V$ such that $w_{0} \Rightarrow w_{1}, w_{1} \Rightarrow w_{2},
> \ldots\, w_{n-1} \Rightarrow w_{n}$, then we say that $w_{n}$ is
> *derivable from* $w_{0}$, and we write $w_{0} \xRightarrow{*}
> w_{n}$.  The sequence of steps used to obtain $w_{n}$ from $w_{0}$
> is called a *derivation*.

. . .

> Let $G = \langle V,T,S,P \rangle$ be a phrase-structure grammar. The
> *language generated by* $G$ (or the *language of* $G$), denoted by
> $L(G)$, is the set of all strings of terminals that are derivable
> from the starting state S. In other words, $L(G) = \{w \in T^{*}|S
> \xRightarrow{*} w\}$.

# Production type determines grammar classification

Per Rosen, section 10.1:

- A *type 0* grammar has no restriction on its productions.
- A *type 1* grammar can have productions only of the form $w_{1}
  \rightarrow w_{2}$, where the length of $w_{2}$ is greater than or
  equal to the length of $w_{1}$, or of the form $w_{1} \rightarrow
  \lambda$.
- A *type 2* (context free) grammar can have productions only of the form $w_{1}
  \rightarrow w_{2}$, where $w_{1}$ is a single symbol that is not a
  terminal symbol.
- A *type 3* (regular) grammar can have productions only of the form $w_{1}
  \rightarrow w_{2}$ with $w_{1} = A$, and either $w_{2} = aB$ or
  $w_{2} = a$, where $A$ and $B$ are nonterminalsymbols and $a$ is a
  terminal symbol, or with $w_{1} = S$ and $w_{2} = \lambda$.

# Regular Expressions

~~~~~~~~~~
(http://)(([a-z]+)\.)+(com|org|edu)/(([a-z]+)/)*

<protocol> ::= http://
<letter>   ::= a|b|c|d|e|f|g|h|i|j|k|l|m
<letter>   ::= n|o|p|q|r|s|t|u|v|w|x|y|z
<slash>    ::= /
<dot>      ::= .
<string>   ::= <letter><string>|<letter>
<host>     ::= <string><dot><host>|<string><dot>
<domain>   ::= com|org|edu
<site>     ::= <host><domain><slash>
<dir>      ::= <string><slash>
<body>     ::= <dir><body>|<dir>
<url>      ::= <protocol><site><body>|<protocol><site>
~~~~~~~~~~

# Nondeterministic Finite State Automaton

![Parser for URL grammar](nfa5.eps)


# Deterministic Finite State Automaton

![Parser for URL grammar](dfa5b.eps)
